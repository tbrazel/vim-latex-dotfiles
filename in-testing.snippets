# This file contains snippets for typesetting LaTeX
#
priority 10

global !p

import re
import hashlib
import time

def hashTimeStamp():
	hash = hashlib.sha1()
	hash.update(str(time.time()).encode('utf-8'))
	return hash.hexdigest()[:10]


#import pynput
#from pynput.keyboard import Key, Controller

#keyboard = Controller()

#def jump_snip():
#    keyboard.press(Key.tab)
#    keyboard.release(Key.tab)

# Checks if a string is a backslash. Used in snippets where you want to expand after a backslash
def isbackslash(string):
    if string == '\\':
	    return ''
    return string

# Functions for adding optional superscripts for sums, products, etc.
def superscriptstart(t):
	if t:
		return '^{'
	return ''
def superscriptend(t):
	if t:
		return '}'
	return ''

#######################

def complete(t, opts):
	if t:
		opts = [ m[len(t):] for m in opts if m.startswith(t) ]
	if len(opts) == 1:
		return opts[0]
	return "(" + '|'.join(opts) + ')'

environmentsarray = ['proposition','corollary','theorem']


# Context for things to be expanded at the end of a line, but not the middle
def endofline():
	if vim.eval('col(".") >= col("$") - 1'):
		return True
	return False

# Context for only expanding on the first line (used for templates, etc.)
# def beginningOfDocument():
#    return vim.eval('line(".")== 1')

# Counts number of extra { in a string
def closedbrackets(string):
	x = string.count('{')
	y = string.count('}')
	z = x - y
	return z

def parse_arrow_direction(string):
	up = string.count('u')
	down = string.count('d')
	right = string.count('r')
	left = string.count('l')
	
	output = 'd'*down + 'u'*up + 'r'*right + 'l'*left
	return output

def parse_arrow_label(arrowdir,string):
	up = arrowdir.count('u')
	down = arrowdir.count('d')
	right = arrowdir.count('r')
	left = arrowdir.count('l')
	
	if down > 0:
		if right > 0:
			if string == 'a' or string == 'r':
				output = ' above right'
			elif string == 'b' or string == 'l':
				output = ' below left'
			else:
				output = ''
		elif left > 0:
			if string == 'a' or string == 'l':
				output = ' above left'
			elif string == 'b' or string == 'r':
				output = ' below right'
		else:
			if string=='l':
				output = ' left'
			elif string=='r':
				output = ' right'
			else:
				output = ''
	elif up > 0:
		if right > 0:
			if string == 'a' or string == 'l':
				output = ' above left'
			elif string == 'b' or string == 'r':
				output = ' below right'
			else:
				output = ''
		elif left > 0:
			if string == 'a' or string == 'r':
				output = ' above right'
			elif string == 'b' or string == 'l':
				output = ' below left'
		else:
			if string=='l':
				output = ' left'
			elif string=='r':
				output = ' right'
			else:
				output = ''
	elif down == 0 and up == 0:
		if string == 'a':
			output = ' above'
		if string == 'b':
			output = ' below'
	else:
		output = ''
	return output

def envtest():
	return 1


def greeklet(string):
	# List of lowercase Roman letters and the associated mappings to Greek letters
	# Obtained from the mapping of the standard Greek alphabet keyboard
	greekAlphabet = [['a','alpha'],['b','beta'],['c','xi'],['d','delta'],['e','epsilon'],['f','phi'],['g','gamma'],['h','eta'],['i','iota'],['k','kappa'],['l','lambda'],['m','mu'],['n','nu'],['o','omega'],['p','pi'],['q','theta'],['r','rho'],['s','sigma'],['t','tau'],['u','upsilon'],['v','omega'],['w','omega'],['x','chi'],['y','psi'],['z','zeta']]
	romanAlphabet = [j[0] for j in greekAlphabet]
	if string.lower() in romanAlphabet:
		roman_index = romanAlphabet.index(string.lower())
		greek_letter = greekAlphabet[roman_index][1]
		if string.isupper():
			return greek_letter.capitalize()
		else:
			return greek_letter
	else:
		return 'ERR'

endglobal


global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'V', 'W', 'X', 'Y', 'Z']]
# If you have http://www.drchip.org/astronaut/vim/vbafiles/amsmath.vba.gz,
# you want to add:
texMathZones += ['texMathZone'+x for x in ['E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS']]
texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

def isMath():
    synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
    if not set(texIgnoreMathZoneIds).isdisjoint(synstackids):
        return False
    return not set(texMathZoneIds).isdisjoint(synstackids)
    # isdisjoint() can short-circuit as soon as a match is found

def prose():
	return not isMath()

endglobal

######

# Common Regex
#

#	([\s\d\",._=:\$\/\(\)\{\}\[\]\\]|^)	matches common tex prefixes: space, .,$([{}])\0123456789
#	(.*?)				matches anything

#	(d*l*|u*r*)			to be used for arrows TODO


######


#snippet '([\s\d,._:=\$\/\(\)\{\}\[\]\\]|^)([durl]+)ar([abrl]*)' "arrow automatic" r
#\\ar[`!p
#snip.rv = parse_arrow_direction(match.group(2))
#`, "${2:label}"`!p
#if match.group(3):
#	snip.rv = parse_arrow_label(match.group(2),match.group(3))
#`] $0
#endsnippet





snippet statustest "Status" b
status $1`!p snip.rv=complete(t[1], ['new', 'incomplete','invalid'])`
endsnippet


snippet timestamp "description"
`!p if not snip.c: snip.rv = hashTimeStamp()`
endsnippet
	


##############################################

# Custom #

##############################################

#############
#### Math
#############

#snippet _{ "subscript automatic" iA
#_{$1}$0
#endsnippet

#snippet ^{ "superscript automatic" iA
#^{$1}$0
#endsnippet

#snippet ^ "superscript" iA
#^`!p
#if t[1]:
#	if len(t[1])>= 2:
#		if t[1][0] =='s' and t[1][1] == 'c':
#			snip.rv = '{ '
#		elif t[1][0] =='f' and t[1][1] =='k':
#			snip.rv = '{ '
#		else:
#			snip.rv = '{'
#	else:
#		snip.rv = '{'
#else:
#	snip.rv = ''
#`${1}`!p
#if t[1]:
#	if t[1][len(t[1]) -1] == '}':
#		if closedbrackets(t[1])== -1:
#			snip.rv = ''
#		else:
#			snip.rv = '}'
#	else:
#		if closedbrackets(t[1]) > 1:
#			z = '}'*closedbrackets(t[1])
#			snip.rv = z + 'test'
#		else:	
#			snip.rv = '}'
#else:
#	snip.rv = ''
#`$0
#
#$1
#endsnippet


#snippet "([a-zA-Z])hat" "Hat over letter on trigger" ri
#\\hat{`!p snip.rv=match.group(1)`}
#endsnippet


#snippet '([\s\d,._:=\$\/\(\)\{\}\[\]\\]|^)xto' "Arrow with label over" irA
#`!p snip.rv = isbackslash(match.group(1))`\\xto{$1} $0
#endsnippet

##################################################
##### Other stuff yet to be tested -- don't commit

snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)//' "Automatic fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet




# Only for homological algebra, delete after
# snippet * "dot" iA
# ^{${1:\\dot}}$0
# endsnippet




# TODO add align* context for these
snippet \\to "and to" iA
&\\to
endsnippet

snippet \\mapsto "and mapsto" iA
&\\mapsto
endsnippet

snippet stackrel "stackrel"
\stackrel{${1:above}}{${2:below}} ${3}
endsnippet

snippet table "Table environment" b
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}
	\begin{${4:t}${4/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}}{${5:c}}
	$0${5/(?<=.)(c|l|r)|./(?1: & )/g}
	\end{$4${4/(t)$|(a)$|(.*)/(?1:abular)(?2:rray)/}}
\end{table}
endsnippet

snippet fig "Figure environment" b
\begin{figure}[${2:htpb}]
	\centering
	\includegraphics[width=${3:0.8}\linewidth]{${4:name.ext}}
	\caption{${4/(\w+)\.\w+/\u$1/}$0}
	\label{fig:${4/(\w+)\.\w+/$1/}}
\end{figure}
endsnippet


snippet inveritble "" A
invertible
endsnippet





snippet que "question"
\\begin{question} $1
\\end{question}
$0
endsnippet

snippet ans "answer"
\\begin{answer} $1
\\end{answer}
$0
endsnippet


# Differential Geometry

snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)nab' "nabla" r
`!p snip.rv = isbackslash(match.group(1))`\\nabla_{$1} $0
endsnippet

context "isMath()"
snippet nabbar "bar nabla" iA
\\bar{\\nabla}$0
endsnippet

snippet '([\s\d,.\$\/\(\)\|\{\}\[\]\\]|^)sm' "smash product" r
`!p snip.rv = isbackslash(match.group(1))`\\smashprod$0
endsnippet


# Number theory
snippet |.| "cdot valuation" iA
|\\cdot|
endsnippet







# Vakil - AG
snippet vex "Vakil exercise"
\\begin{exercise}[$1]\\label{ex:$1} $2
\\end{exercise}
$0
endsnippet

# MATH702
context "prose()"
snippet qf "description"
quadratic form
endsnippet





context "prose()"
snippet qs "description"
quadratic space
endsnippet

context "prose()"
snippet ani "description"
anisotropic
endsnippet

context "prose()"
snippet iso "description"
isotropic
endsnippet


# K-theory
context "isMath()"
snippet Kr "reduced Ktheory" iA
\\til{K}
endsnippet

context "isMath()"
snippet Hr "reduced cohomology" iA
\\til{H}
endsnippet

context "isMath()"
snippet pf "Pfister"
\\Pfister{$1}
endsnippet


context "isMath()"
snippet '([\s\d\",._=:\$\/\(\)\|\{\}\[\]\\]|^)l;' "left parentheses" riA
`!p snip.rv = isbackslash(match.group(1))`\\left( $1 \\right)$0
endsnippet

# vim:ft=snippets:
